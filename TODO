                                                  -*- indented-text -*- 
$Id$

 * Licensing

   * Will the GNU Lesser GPL work?  Specifically, will it be a problem
     in distributing this with Mozilla or Apache?  

 * Checksums

   * Allow variable-length checksums in the signature; the signature
     will have to describe the length of the sums and we must compare
     them taking this into account.

 * Testing

   * Test files >2GB, >4GB.  Presumably these must be done in streams
     so that the disk requirements to run the test suite are not too
     ridiculous. 

 * Web site in Latte

 * Use slprintf not strnprintf, etc.

 * Long files

   * How do we handle the large signatures required to support large
     files?  In particular, how do we choose an appropriate block size
     when the length is unknown?  Perhaps we should allow a way for
     the signature to scale up as it grows.

   * What do we need to do to compile in support for this?

     * On GNU, defining _LARGEFILE_SOURCE as we now do should be
       sufficient.

     * SCO and similar things on 32-bit platforms may be more
       difficult.

     * On larger Unix platforms we hope that large file support will
       be the default.

 * Perhaps make extracted signatures still be wrapped in commands.
   What would this lead to?

   * We'd know how much signature data we expect to read, rather than
     requiring it to be terminated by the caller.

 * Selective trace of particular areas of the library.

 * Try to make libhsync more generally useful

   * Tease apart the different algorithms inside the library so that
     they can be independently re-used.

   * Use more specific names than `encode' and `decode'.  I like
     `apply' as a description of what the client does. 

   * Don't imply any particular encoding format.  I don't think we
     need callbacks; it's enough that all the users can write their
     own implementations of the loops.

   * This ought to make it simpler to get push-structured interfaces. 

 * More thorough testing

   * Check the encoded file checksum against the real mdfour sum of
     the file?  The code's pretty simple, so hopefully this is not a
     problem. 

   * mdfour

     * keep some example files and check that they give the expected
       results. 

     * try using different input chunk sizes

   * abstract i/o

     * rewrite cat to use our routines, and make sure it passes the
       file through correctly however we call it.  Different
       strategies are possible: using the loop functions or not, using
       mapptrs, etc.

   * test within the proxy

     * We need dynamically generated reproducible content that varies
       in an interesting way.  cvsweb sounds ideal: we'll mirror the
       output of cvsweb through a proxy and then not through a proxy,
       and see how we go.

   * run regression suite from CVS every night

 * Portability

   * Tux only knows what portability assumptions we've made.

   * In particular, running this on a risc box would be interesting.
     Endianness?

